## 스프링 핵심 원리 이해1 - 예제
 회원 가입 및 물건 주문 <br/>
 (스프링 프레임워크보단 순수한 자바로만 개발이 진행됨)<br/>
 
 * 프로젝트 생성
 
 사전 준비<br/>
 자바: Java 11<br/>
 IDE: IntelliJ<br/>
 <br/>
 간단한 환경 설정을 위해 스프링 부트를 사용.<br/>
 -[spring.](https://start.spring.io/)<br/>
 -dependency를 설정하지 않으면 스프링 부트가 스프링 코어쪽 라이브러리만 가지고 최소한도로 알아서 구성해줌<br/>
 <br/>
 build.gradle로 프로젝트 시작<br/>
 -IntelliJ: settings-gradle(검색)-gradle projects에서 'build and run using', 'run tests using' 둘다 IntelliJ IDEA로 바꿔주면 런 하거나 테스트 할 때 더 빨리 할 수 있다.)<br/>
<br/>
<br/>
 * 비즈니스 요구사항과 설계
<br/>
 요구사항 중 구체적으로 확정되지 않은 부분이 있다면 인터페이스만 만들어두고 추후 구현체를 집어넣음으로써 완성되도록 설계(객체 지향 설계 방법)
<br/>
<br/>

* 회원 도메인 설계

<br/>
 회원 도메인 요구사항<br/><br/>
 1. 기능: 회원 가입, 회원 조회<br/>
 2. 회원 등급: 일반, VIP<br/>
 3. 회원 데이터 저장: 자체 DB 구축, 혹은 외부 시스템과 연동 (미확정)<br/>
<br/>
 //다이어그램을 통한 요구사항 이해<br/>
 회원 도메인 협력 관계<br/>
 -가장 큰 그림, 기획자들도 함께 보고 의논 가능.<br/>
 -DB가 확정되지 않았으므로 인터페이스를 만들어두고 DB를 확정한 후에 구현체 개발(요구사항 3)<br/>
 <br/>
 회원 클래스 다이어그램<br/>
 -회원 도메인 협력 관계도를 구체화. <br/>
 -인터페이스, 구현체 有. <br/>
 -서버를 실행하지 않고 눈으로 클래스를 확인 가능.(정적 리뷰)<br/>
 -동적으로(서버실행) 결정되는 면이 있음(ex. 리포지토리 선택 등)<br/>
 <br/>
 회원 객체 다이어그램<br/>
 -서버가 돌아갈 때 클라이언트가 실제로 사용하는 인스턴스 간의 관계를 분명히 명시.<br/>
 -개발자는 클래스 다이어그램과 객체 다이어그램을 보고 개발.<br/>
 <br/><br/>
 
* 회원 도메인 개발
 <br/>
 Grade(enum): 회원 등급<br/>
 Member: 회원 정보 클래스(아이디, 이름, 회원 등급)<br/>
 MemberRepository: 회원 저장소 인터페이스(저장, 아이디로 회원 찾기)<br/>
 MemberService: 회원 서비스 인터페이스(가입, 아이디로 회원 찾기)<br/>
 MemverServiceImpl: 회원 서비스 구현체, 회원 서비스 인터페이스를 상속받음<br/>
 
 ```
 private final MemberRepository memberRepository = new MemoryMemberRepository();
 //구현 객체를 선정해야(new MemoryMemberRepository();) NULL문제가 안 터짐
 ```
 
 MemoryMemverRepository: 회원 저장소 구현체, 자체 메모리를 db로 사용한 경우
 
 ```
 //저장소니까 Map 값 필요
 //원래는 그냥 HashMap<>()을 쓰면 동시성 문제가 발생할 수 있으나 예제 프로젝트이므로 간단하게.
 private static Map<Long, Member> store = new HashMap<>();
 ```
 
* 회원 도메인 실행과 테스트

 main 함수 안에서 직접 테스트 코드를 짜는 건 비효율적이다.<br/>
 따라서 Junit이라는 테스트 유닛을 사용.<br/>
 (test-...-member-MemberServiceTest.java)<br/>
 
 ```
 //given
 //when
 //then(검증)
 //의 구성. then 단계에서 테스트 결과를 도출.
 ```
 
 Assertions (org.asssertj.core.api)를 사용함으로써 눈으로 직접 콘솔창을 보면서 검증하지 않아도 된다.<br/>
 
 ***회원 도메인 설계의 문제점*** <br/>
 -OCP, DIP 준수 문제<br/>
 -MemberServiceImpl에서 MemberRepository뿐만 아니라 MemoryMemberRepository까지 의존 ->DIP 깸<br/>
 <br/>
 <br/>
 
 * 주문과 할인 도메인 설계 <br/>

 주문과 할인 정책<br/>
 1. 회원: 상품 주문<br/>
 2. 회원 등급에 따른 차등적 할인 정책<br/>
 3. 할인 정책: VIP는 1000원 고정 할인(정액 할인 정책인 경우)<br/>
 4. 할인 정책 미확정<br/>
<br/>
 주문 도메인 협력 관계<br/>
 
 1. 클라이언트 -> 주문 서비스(역할): 주문 생성(회원 아이디, 상품명, 상품 가격)
 //상품명과 상품 가격으로 상품 데이터 단순하게 처리
 2. 주문 서비스 -> 회원 저장소(역할): 회원 조회(회원 등급에 따라 할인정도가 다르므로)
 3. 주문 서비스 -> 할인 정책(역할): 할인 적용
 4. 주문 서비스(역할) -> 클라이언트: 주문 결과 반환(주문 데이터 저장 단순화)
<br/>
 주문 도메인 전체<br/>
 -주문 도메인 역할 + 구현(분리)<br/>
 -구현 객체의 자유로운 조립 가능 -> 할인 정책, 회원 저장소 모두 유연하게 변경 가능<br/>
<br/>
 주문 도메인 클래스 다이어그램<br/>
 -객체 레벨로 구현<br/>
 -인터페이스 + 구현체<br/>
 <br/>
 주문 도메인 객체 다이어그램1<br/>
 -클래스 다이어그램과 다르게 실제로 new로 객체를 생성해서 동적으로 객체들의 연관관계를 표현<br/>
 -메모리 회원 저장소 + 정액 할인 정책의 경우<br/>
 <br/>
 주문 도메인 객체 다이어그램2<br/>
 -db 회원 저장소 + 정률 할인 정책의 경우<br/>
 <br/>
 
 ***1->2로 바꿔도 주문 서비스는 변경할 필요 없음***
 
<br/>
<br/>
<br/>

* 주문과 할인 도메인 개발 <br/>

 -할인 정책 인터페이스 생성<br/><br/>
 -정액 할인 정책 구현체 생성: 객체 다이어그램1<br/>
  ㄴvip인 경우 정액 할인 가격 반환(return)<br/><br/>
 -주문 클래스 생성: 회원아이디, 상품명, 상품가격, 할인가격이 들어있는 주문 객체(Order)<br/><br/>
 -주문 서비스 인터페이스: Order createOrder<br/><br/>
 -주문 서비스 구현체<br/>
  ㄴ메모리 회원 저장소 + 정액 할인 정책 사용<br/>
  ㄴ회원 조회 - 할인 정책 적용 - 최종 주문 객체 생성+리턴<br/>
<br/>

* 주문과 할인 도메인 테스트 <br/>

 -역시나 main 메소드로 하는 것은 좋지 않음 -> Junit (test 폴더에..)<br/><br/>
 -OrderServiceTest.java<br/><br/>
 -회원을 위한 회원 서비스 구현 객체<br/><br/>
 -주문을 위한 주문 서비스 구현 객체<br/><br/>
 
 ```
 //then
  Assertions.assertThat(order.getDiscountPrice()).isEqualTo(1000);
 ```
 
 <br/><br/><br/>
 
 
 
 
 
 
 
 
 
 
 
 
