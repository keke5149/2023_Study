## 웹 애플리케이션 이해

#### 웹 서버, 웹 애플리케이션 서버

-웹은 HTTP를 기반으로 통신한다. <br/>
-http 메세지로 데이터를 주고 받음, 거의 모든 형태의 데이터를 전송 가능 <br/>
 <br/>
 
- 웹 서버 <br/>
-http 프로토콜 기반 동작 <br/>
-정적 리소스 제공:  http 프로토콜로 정적 파일을 주고 받음(요청-응답) <br/>
 <br/>
 
- 웹 애플리케이션 서버(WAS) <br/>
-http 기반 동작 <br/>
-웹 서버 기능을 포함하고 있음(정적 리소스도 제공 가능) <br/>
-동적으로 동작(코드 실행 가능->애플리케이션 로직 수행 가능) <br/>
ㄴhttp 요청이 들어오면 사용자에 따라 다른 동작 가능 <br/>
ㄴ동적 html, http api <br/>
 <br/>
 
- 웹 서버, WAS 차이 <br/>
-웹 서버: 정적 리소스/WAS: 애플리케이션 로직 <br/>
-서로 겹치는 부분 있음.(확실하게 구분되지는 않는다.) <br/>
-WAS는 애플리케이션 코드를 실행하는 데에 더 특화되어있음. <br/>
 <br/>
 
- 웹 시스템 구성: WAS, DB <br/>
-시스템 = WAS+DB <br/>
-WAS가 정적/동적 모두 커버 <br/>
->WAS에서 하는 일이 너무 많음-> 서버 과부하 우려 <br/>
->서버가 다운되면(WAS 장애) 오류 화면(HTML)조차 노출 X <br/>
 <br/>
 
- 웹 시스템 구성:  WEB, WAS, DB <br/>
-시스템 = WEB+WAS+DB <br/>
-정적 리소스 처리 -> 웹 서버 <br/>
-동적인 처리(애플리케이션 로직) -> WAS(웹 서버에서 위임) <br/>
ㄴ정적 리소스 사용 증가->웹 서버 증설 <br/>
ㄴ애플리케이션 로직 사용 증가->WAS 증설 <br/>
->효율적 <br/>
-장애는 웹 서버보다 WAS 서버에서 자주 일어남. <br/>
 <br/>
+++API로 데이터 전송만 할 경우엔 웹 서버는 없어도 됨(WAS 서버만 있어도 동작) <br/>
 <br/>
 <br/>
 
#### 서블릿

-웹 애플리케이션 서버에서 직접 구현하는 경우(웹 브라우저에서 온 HTTP 메시지: 회원 저장) <br/>
: 네트워크 연결-HTTP 요청 메시지 관련 작업-저장 프로세스 실행-비즈니스 로직 실행-HTTP 응답 메시지 생성 관련 작업-네트워크 관련  <br/>
->비즈니스 로직 실행 파트만 개발자에게 있어서 의미 있는 부분임. <br/>
 <br/>
-서블릿을 지원하는 WAS을 사용하는 경우 <br/>
:비즈니스 로직 실행 부분을 제외한 모든 작업을 서블릿이 해줌. <br/>
 <br/>
 
- 서블릿 <br/>
-특징:  <br/>
//@WebServlet(name="helloServlet", urlPatterns="/hello") <br/>
-urlPattern의 url이 호출되면 (웹 브라우저에 '/hello' 주소가 뜨면) 서블릿 코드가 실행됨. <br/>
-'HttpServlet'을 상속받아서 애플리케이션 로직만 작성하면 됨. <br/>
-파라미터 'HttpServletRequest', 'HttpServletResponse'(객체를 생성해서 서블릿 컨테이너에 넘김) <br/>
 <br/>
 
- 서블릿: HTTP 요청/응답 흐름 <br/>
-HTTP 요청 시 <br/>
->WAS에서 Request, Response 객체를 새로 만들어서 서블릿 객체 호출... <br/>
->Request 객체(http 요청 정보), Response 객체(http 응답 정보); 개발자 조작/사용 <br/>
->WAS는 Response 객체 내의 내용으로 HTTP 응답 메시지 생성, 웹 브라우저에 전달 <br/>
 <br/>
 
- 서블릿 컨테이너 <br/>
: 서블릿을 지원하는 WAS. <br/>
-서블릿 컨테이너 안에 서블릿 객체가 자동으로 생성됨. <br/>
-서블릿 컨테이너는 서블릿 객체의 전 생명주기(생성-초기화-호출-종료)를 관리 <br/>
-서블릿 객체는 싱글톤으로 관리된다.(단 하나의 객체, 공유, 컨테이너 종료 시 객체도 종료) <br/>
->매 요청에 새로운 객체를 생성하는 것은 비효율적.(Request 객체, Response 객체와는 다르게. 얘네는 당연히 요청마다 달라야 함.) <br/>
->서블릿 객체는 재활용된다. <br/>
->공유 변수 사용 주의 <br/>
-JSP도 서블릿으로 변환되어서 사용됨. <br/>
-멀티스레드 지원. <br/>
 <br/>
 <br/>
 
#### 동시 요청-멀티 쓰레드

//웹 브라우저가 HTTP 리퀘스트를 보내면(TCP/UDP 연결 有) WAS가 받아서 서블릿 객체를 호출함. 이때 이 서블릿 객체는 누가 호출하는가? 답: 쓰레드 <br/>
 <br/>
 
- 쓰레드 <br/>
: 애플리케이션 코드를 순차적으로 실행하는 것.(프로세스: 프로그램을 실행) <br/>
-자바 메인 메서드를 처음 실행하면 "main" 쓰레드가 실행됨. <br/>
-쓰레드가 없으면 자바 애플리케이션 실행 자체가 불가능. <br/>
-동시 처리 -> 쓰레드를 추가해서 실행 <br/>
 <br/>
-단일 요청: 쓰레드 1개 <br/>
: http 요청이 오면 쓰레드 하나 할당. 이 쓰레드로 서블릿 코드를 실행함. 이 쓰레드로 http 응답까지 처리. <br/>
-다중 요청: 쓰레드 1개 <br/>
: 요청 1의 쓰레드에서의 처리가 지연되고 있을 때 요청 2가 들어오면 요청 2는 쓰레드 대기.  <br/>
-> 요청 1, 요청 2 모두 죽음.  <br/>
 <br/>
-다중 요청: 요청마다 신규 쓰레드 생성  <br/>
->장점:  <br/>
ㄴ동시 요청 처리 <br/>
ㄴ하나가 지연되도 나머지 쓰레드에 영향 x <br/>
->단점: <br/>
ㄴ쓰레드 생성 비용은 매우 비쌈(요청 증가->응답 속도 저하) <br/>
ㄴ쓰레드는 컨텍스트 스위칭 비용 발생 <br/>
ㄴ쓰레드 생성에 제한 x(요청 급증-> 리소스 사용량 급증-> 서버 다운 가능성 증가) <br/>
->해결: 쓰레드 풀(WAS 내부에 존재) <br/>
 <br/>
 
- 쓰레드 풀 <br/>
 <br/>
-쓰레드 풀에서 쓰레드xN개 존재/보관/관리(최대치 설정 有, 변경 가능) <br/>
-요청이 오면 쓰레드 풀에 쓰레드를 요청함 <br/>
-쓰레드 사용이 끝나면 쓰레드 풀에 반납 <br/>
-매번 쓰레드를 생성/종료 X. 쓰레드 풀에 만들어둔 쓰레드를 계속 사용. <br/>
->쓰레드 풀에 남아있는 쓰레드가 없는 경우(모든 쓰레드가 실행 중)->요청들을 대기시키거나 거절함.(알아서 설정) <br/>
 <br/>
-쓰레드 풀 장점 <br/>
ㄴ 쓰레드 생성/종료 비용(CPU) 절약, 응답 시간 빠름 <br/>
ㄴ쓰레드 생성량 최대치 有, 요청 급증에도 이미 들어와 있는 요청 처리에는 문제 없음. <br/>
 <br/>
-쓰레드 풀 실무 팁: Max thread 수  <br/>
ㄴ너무 낮음 ->(동시 요청이 많을 때) 요청 처리 비효율. CPU는 남아도는데 클라이언트 응답은 지연됨. <br/>
ㄴ너무 높음 ->(동시 요청이 많을 떼) CPU 사용 과다. 리소스 사용 임계점 초과->서버 다운 <br/>
ㄴ적정값을 찾는 게 중요. 서버 늘리기(클라우드)-튜닝으로 장애 해결하기. <br/>
 <br/>
-쓰레드 풀의 max thread 적정 숫자  <br/>
ㄴ상황에 따라 다름...(로직 복잡도, 리소스 상황에 따라) <br/>
->성능 테스트로 찾기 <br/>
ㄴ가능한한 실제 서비스와 유사하게  <br/>
ㄴ툴: 아파치 ab, 제이미터 등  <br/>
 <br/>
// WAS의 멀티쓰레드 지원  <br/>
-멀티 쓰레드 부분은 WAS가 처리  <br/>
-개발자는 신경X, 싱글 쓰레드처럼 소스 코드를 개발하면 됨.(개발 생산성 UP) <br/>
-싱글톤 객체(서블릿, 스프링 빈) 주의//공유 변수 등등. <br/>
 <br/>
 <br/>
 
#### HTML, HTTP API, CSR, SSR

- 정적 리소스 <br/>
-고정된 HTML/CSS/JS/이미지 등 파일 <br/>
-> 웹 브라우저에서 파일을 요청하면 웹 서버에서 이미 생성되어 있는 파일을 찾아서 제공.  <br/>
 <br/>
 
- 동적인 HTML <br/>
-요청에 따라 WAS(애플리케이션 로직 실행)가 DB에서 주문 정보를 조회하고 동적으로 HTML을 생성한 후(view template) 웹 브라우저에 전달. 웹 브라우저는 전달받은 html을 해석해서(렌더링) 화면에 띄운다. <br/>
 <br/>
 
- HTTP API: HTML이 아닌 데이터 전달. <br/>
-주로 JSON 형식 <br/>
-데이터만 주고 받으므로 제대로 된 UI 화면이 필요하면 클라이언트에서 별도로 처리해야 함. <br/>
->WAS 서버가 DB에 주문 정보를 조회해서 얻은 JSON 형식의 데이터는 다양한 시스템으로 전달됨. 각 시스템에서 데이터를 원하는 대로 처리함. <br/>
-UI 클라이언트 접점: 웹 클라이언트(리액트, Vue.js 등), 앱 클라이언트(아이폰, 안드로이드, PC 앱) , 웹 브라우저에서 자바스크립트로 HTTP API 호출.//여기서 사용 <br/>
-서버 to 서버 통신//여기서도 사용. <br/> 
 <br/>
 
_정적 리소스/동적으로 제공되는 HTML 페이지/HTTP API를 어떻게 제공할 것인가._ <br/>
 <br/>
 
- SSR: 서버 사이드 렌더링 <br/>
: 클라이언트에서 서버로 요청을 넣었을 때, (DB 조회까지 한 후)서버에서 동적으로 최종 HTML을 생성해서 클라이언트에 전달. <br/>
-웹 브라우저는 서버가 보낸 HTML 코드를 렌더링해서 보여주기만 함. <br/>
-정적 화면에 많이 사용 <br/>
-JSP, 타임리프//백엔드 <br/>
 <br/>
 
- CSR: 클라이언트 사이드 렌더링 <br/>
-최종 HTML을 받아오는 게 아니고 웹 브라우저에서 자바스크립트를 통해 동적으로 HTML을 생성 및 적용.(클라이언트 쪽에서 화면을 만드는 것) <br/>
-서버에서 응답으로 오는 HTML에는 아무 내용이 없음. 자바스크립트 링크(애플리케이션 구동용)만 있다. <br/>
-웹 브라우저가 서버에 이 자바스크립트(클라이언트 로직, HTML 렌더링 코드)를 요청.  <br/>
-클라이언트 로직, HTML 렌더링 코드를 응답받으면, 웹 브라우저는이번에 HTTP API 로 서버를 호출(데이터를 요청)함. <br/>
-웹 서버가 DB에서 주문 정보를 조회해서 JSON 형식의 데이터를 보내주면(응답), 웹 브라우저는 자바스크립트의 클라이언트 로직과 HTML 렌더링 코드를 가지고 동적으로 최종 HTML을 렌더링 <br/>
-동적 화면에 많이 사용. 앱처럼 동작.(부분변경 가능) <br/>
-리액트, Vue.js//웹 프론트엔드 <br/>
 <br/>
  <br/>
  
#### 자바 백엔드 웹 기술 역사

- 역사... <br/>
-서블릿: 자바 코드로 짜야 함->HTML을 동적으로 생성하기 어럽다. <br/>
-JSP: HTML, 자바 코드 모두 작성 가능->비즈니스 로직도 여기서->JSP 파일이 너무 커짐 <br/>
-MVC 패턴: 서블릿, JSP 조합/모델(비즈니스 로직), 뷰(화면 관련), 컨트롤러 <br/>
-MVC 프레임워크: MVC 패턴 자동화. 다양한 기능 지원. <br/>
 <br/>
 
- 현재 <br/>
-애노테이션 기반의 스프링 MVC (서블릿 위에서 동작함) <br/>
-스프링 부트: 서버(WAS) 내장//빌드 결과(Jar 파일) 안에 톰캣 서버가 포함되어 있음-> 빌드하면 서버가 바로 뜸(내가 만든 코드도 같이 뜸) <br/>
 <br/>
 
- 최신: 스프링 웹 기술의 분화 <br/>
-Web Servlet: Spring MVC(기본) <br/>
-Web Reactive: Spring WebFlux(최신)->아직은 잘 쓰이지 않음. (어렵고.. <br/>
ㄴ특징:  <br/>
->비동기 non-blocking 처리 <br/>
->최소 쓰레드로 최대 성능//쓰레드 수를 CPU 코어 수에 (거의) 맞춤->쓰레드 무한 동작 가능->컨텍스트 스위치 비용 최소화 <br/>
->함수형 스타일로 개발 -> 동시처리 코드 효율화 <br/>
->서블릿 기술 사용x("네티" 웹 프레임워크 사용) <br/>
 <br/>
 
- 자바 뷰 템플릿 역사 <br/>
//뷰 템플릿: HTML의 편리한 생성을 위해... <br/>
-JSP: 느림, 기능 부족, html 파일을 열면 JSP 코드도 보임 <br/>
-프리마커, 벨로시티: 속도 빠름, 다양한 기능 <br/>
-타임리프(Thymeleaf):  <br/>
ㄴ내추럴 템플릿: HTML 모양 유지(깔끔, 필요한 부분엔 태그 처리) <br/>
ㄴ스프링에서 밀어줌(스프링 MVC와 강력한 결합) <br/>
ㄴ속도는 프리마커/벨로시티가 더 빠르긴 함. <br/>
 <br/>
  <br/>
